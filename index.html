<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FTMS Bike Trainer Console</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: #1a1a2e; color: #eee; padding: 20px; min-height: 100vh; }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 20px; color: #00d4ff; }
        .connection { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer;
                 font-size: 16px; transition: all 0.2s; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: #00d4ff; color: #1a1a2e; }
        .btn-primary:hover:not(:disabled) { background: #00a8cc; }
        .btn-secondary { background: #4a4a6a; color: #eee; }
        .btn-secondary:hover:not(:disabled) { background: #5a5a7a; }
        .btn-danger { background: #ff4757; color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #ff3344; }
        .btn-hrm { background: #ff6b81; color: #fff; }
        .btn-hrm:hover:not(:disabled) { background: #ff4757; }
        .btn-csc { background: #7bed9f; color: #1a1a2e; }
        .btn-csc:hover:not(:disabled) { background: #2ed573; }
        .status { text-align: center; padding: 10px; margin-bottom: 20px; border-radius: 8px; font-size: 14px; }
        .status.connected { background: #2ed57320; border: 1px solid #2ed573; }
        .status.disconnected { background: #ff475720; border: 1px solid #ff4757; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .metric { background: #252545; padding: 20px; border-radius: 12px; text-align: center; }
        .metric-value { font-size: 36px; font-weight: bold; color: #00d4ff; }
        .metric-unit { font-size: 14px; color: #888; }
        .metric-label { font-size: 12px; color: #aaa; margin-top: 5px; text-transform: uppercase; }
        .controls { background: #252545; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 8px; color: #aaa; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { text-align: center; font-size: 24px; color: #00d4ff; }
        .gears { display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap; }
        .gear-display { font-size: 48px; font-weight: bold; color: #ffd700; min-width: 80px; text-align: center; }
        .log { background: #252545; padding: 15px; border-radius: 12px; max-height: 200px; overflow-y: auto; }
        .log-entry { font-family: monospace; font-size: 12px; color: #888; margin-bottom: 5px; }
        .log-entry.error { color: #ff4757; }
        .log-entry.success { color: #2ed573; }
    </style>
</head>
<body>
    <div class="container">
        <h1>FTMS Bike Trainer</h1>

        <div class="connection">
            <button id="connectTrainer" class="btn-primary">Connect Trainer</button>
            <button id="connectHRM" class="btn-hrm">Connect HRM</button>
            <button id="connectCSC" class="btn-csc">Connect Cadence</button>
            <button id="connectClick" class="btn-secondary">Connect Zwift Click</button>
            <button id="disconnect" class="btn-danger" disabled>Disconnect</button>
        </div>

        <div id="trainerStatus" class="status disconnected">Trainer: Disconnected</div>
        <div id="hrmStatus" class="status disconnected">HRM: Disconnected</div>
        <div id="cscStatus" class="status disconnected">Speed/Cadence: Disconnected</div>
        <div id="clickStatus" class="status disconnected">Zwift Click: Disconnected</div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="power">--</div>
                <div class="metric-unit">W</div>
                <div class="metric-label">Power</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="cadence">--</div>
                <div class="metric-unit">rpm</div>
                <div class="metric-label">Cadence</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="speed">--</div>
                <div class="metric-unit">km/h</div>
                <div class="metric-label">Speed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="heartRate">--</div>
                <div class="metric-unit">bpm</div>
                <div class="metric-label">Heart Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="resistance">--</div>
                <div class="metric-unit"></div>
                <div class="metric-label">Resistance</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgPower">--</div>
                <div class="metric-unit">W</div>
                <div class="metric-label">Avg Power</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgSpeed">--</div>
                <div class="metric-unit">km/h</div>
                <div class="metric-label">Avg Speed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgCadence">--</div>
                <div class="metric-unit">rpm</div>
                <div class="metric-label">Avg Cadence</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="totalDistance">--</div>
                <div class="metric-unit">m</div>
                <div class="metric-label">Distance</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="totalEnergy">--</div>
                <div class="metric-unit">kcal</div>
                <div class="metric-label">Energy</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="elapsedTime">--</div>
                <div class="metric-unit"></div>
                <div class="metric-label">Elapsed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="remainingTime">--</div>
                <div class="metric-unit"></div>
                <div class="metric-label">Remaining</div>
            </div>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #aaa;">Virtual Gears</h3>
            <div class="gears">
                <button id="gearDown" class="btn-secondary">&#9664; Easier</button>
                <div class="gear-display" id="currentGear">12</div>
                <button id="gearUp" class="btn-secondary">Harder &#9654;</button>
            </div>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #aaa;">Manual Resistance</h3>
            <div class="control-group">
                <input type="range" id="resistanceSlider" min="0" max="25" value="12" step="0.5">
                <div class="value"><span id="resistanceValue">12</span></div>
            </div>
            <button id="applyResistance" class="btn-primary" disabled>Apply Resistance</button>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #aaa;">Simulation (Grade)</h3>
            <div class="control-group">
                <input type="range" id="gradeSlider" min="-10" max="15" value="0" step="0.5">
                <div class="value"><span id="gradeValue">0</span>%</div>
            </div>
            <button id="applyGrade" class="btn-primary" disabled>Apply Grade</button>
        </div>

        <div class="log" id="log"></div>
    </div>

<script>
// FTMS UUIDs
const FTMS_SERVICE = 0x1826;
const INDOOR_BIKE_DATA = 0x2AD2;
const CONTROL_POINT = 0x2AD9;

// Heart Rate Service UUIDs
const HRM_SERVICE = 0x180D;
const HRM_MEASUREMENT = 0x2A37;

// Cycling Speed and Cadence Service UUIDs
const CSC_SERVICE = 0x1816;
const CSC_MEASUREMENT = 0x2A5B;

// Zwift Click UUIDs - Legacy (pre-2025)
const ZWIFT_SERVICE_LEGACY = '00000001-19ca-4651-86e5-fa29dcdd09d1';
const ZWIFT_ASYNC_LEGACY = '00000002-19ca-4651-86e5-fa29dcdd09d1';
const ZWIFT_SYNC_RX_LEGACY = '00000003-19ca-4651-86e5-fa29dcdd09d1';
const ZWIFT_SYNC_TX_LEGACY = '00000004-19ca-4651-86e5-fa29dcdd09d1';

// Zwift Click UUIDs - New (2025+)
const ZWIFT_SERVICE_NEW = 0xFC82;

// Control Point Opcodes
const OP_REQUEST_CONTROL = 0x00;
const OP_RESET = 0x01;
const OP_SET_TARGET_RESISTANCE = 0x04;
const OP_SET_TARGET_POWER = 0x05;
const OP_START = 0x07;
const OP_STOP = 0x08;
const OP_SET_SIMULATION = 0x11;

// CSC wheel circumference in meters (700x25c default)
const WHEEL_CIRCUMFERENCE = 2.105;

// State
let trainerDevice = null;
let trainerServer = null;
let controlPointChar = null;
let indoorBikeDataChar = null;
let hrmDevice = null;
let cscDevice = null;
let clickDevice = null;
let currentGear = 12;
const MIN_GEAR = 1;
const MAX_GEAR = 24;

// CSC state for delta calculations
let lastCrankRevs = null;
let lastCrankTime = null;
let lastWheelRevs = null;
let lastWheelTime = null;

// DOM Elements
const elements = {
    connectTrainer: document.getElementById('connectTrainer'),
    connectHRM: document.getElementById('connectHRM'),
    connectCSC: document.getElementById('connectCSC'),
    connectClick: document.getElementById('connectClick'),
    disconnect: document.getElementById('disconnect'),
    trainerStatus: document.getElementById('trainerStatus'),
    hrmStatus: document.getElementById('hrmStatus'),
    cscStatus: document.getElementById('cscStatus'),
    clickStatus: document.getElementById('clickStatus'),
    power: document.getElementById('power'),
    cadence: document.getElementById('cadence'),
    speed: document.getElementById('speed'),
    heartRate: document.getElementById('heartRate'),
    resistance: document.getElementById('resistance'),
    avgPower: document.getElementById('avgPower'),
    avgSpeed: document.getElementById('avgSpeed'),
    avgCadence: document.getElementById('avgCadence'),
    totalDistance: document.getElementById('totalDistance'),
    totalEnergy: document.getElementById('totalEnergy'),
    elapsedTime: document.getElementById('elapsedTime'),
    remainingTime: document.getElementById('remainingTime'),
    currentGear: document.getElementById('currentGear'),
    gearUp: document.getElementById('gearUp'),
    gearDown: document.getElementById('gearDown'),
    resistanceSlider: document.getElementById('resistanceSlider'),
    resistanceValue: document.getElementById('resistanceValue'),
    applyResistance: document.getElementById('applyResistance'),
    gradeSlider: document.getElementById('gradeSlider'),
    gradeValue: document.getElementById('gradeValue'),
    applyGrade: document.getElementById('applyGrade'),
    log: document.getElementById('log')
};

// Logging
function log(message, type = 'info') {
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    elements.log.insertBefore(entry, elements.log.firstChild);
    console.log(message);
}

// Format seconds as mm:ss
function formatTime(seconds) {
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    return `${min}:${sec.toString().padStart(2, '0')}`;
}

// Handle UINT16 wraparound for CSC counters
function uint16Diff(current, previous) {
    if (current >= previous) return current - previous;
    return 65536 - previous + current;
}

// Parse Indoor Bike Data characteristic (FTMS bits 0-12)
function parseIndoorBikeData(dataView) {
    const flags = dataView.getUint16(0, true);
    let offset = 2;
    const data = {};

    // Bit 0 = 0 means Instantaneous Speed is present (inverted logic!)
    if ((flags & 0x01) === 0) {
        data.speed = dataView.getUint16(offset, true) / 100; // km/h
        offset += 2;
    }

    // Bit 1: Average Speed
    if (flags & 0x02) {
        data.avgSpeed = dataView.getUint16(offset, true) / 100;
        offset += 2;
    }

    // Bit 2: Instantaneous Cadence
    if (flags & 0x04) {
        data.cadence = dataView.getUint16(offset, true) / 2; // rpm
        offset += 2;
    }

    // Bit 3: Average Cadence
    if (flags & 0x08) {
        data.avgCadence = dataView.getUint16(offset, true) / 2;
        offset += 2;
    }

    // Bit 4: Total Distance (24-bit)
    if (flags & 0x10) {
        data.totalDistance = dataView.getUint16(offset, true) +
                            (dataView.getUint8(offset + 2) << 16);
        offset += 3;
    }

    // Bit 5: Resistance Level
    if (flags & 0x20) {
        data.resistance = dataView.getInt16(offset, true);
        offset += 2;
    }

    // Bit 6: Instantaneous Power
    if (flags & 0x40) {
        data.power = dataView.getInt16(offset, true); // watts
        offset += 2;
    }

    // Bit 7: Average Power
    if (flags & 0x80) {
        data.avgPower = dataView.getInt16(offset, true);
        offset += 2;
    }

    // Bit 8: Expended Energy
    if (flags & 0x100) {
        data.totalEnergy = dataView.getUint16(offset, true); // kcal
        offset += 2;
        data.energyPerHour = dataView.getUint16(offset, true); // kcal/h
        offset += 2;
        data.energyPerMinute = dataView.getUint8(offset); // kcal/min
        offset += 1;
    }

    // Bit 9: Heart Rate
    if (flags & 0x200) {
        data.heartRate = dataView.getUint8(offset); // bpm
        offset += 1;
    }

    // Bit 10: Metabolic Equivalent
    if (flags & 0x400) {
        data.metabolicEquiv = dataView.getUint8(offset) / 10;
        offset += 1;
    }

    // Bit 11: Elapsed Time
    if (flags & 0x800) {
        data.elapsedTime = dataView.getUint16(offset, true); // seconds
        offset += 2;
    }

    // Bit 12: Remaining Time
    if (flags & 0x1000) {
        data.remainingTime = dataView.getUint16(offset, true); // seconds
        offset += 2;
    }

    return data;
}

// Update UI with bike data from FTMS trainer
// Skip cadence/avgCadence when external CSC sensor is connected
// Skip heart rate when external HRM is connected
function updateMetrics(data) {
    if (data.power !== undefined) elements.power.textContent = data.power;
    if (data.cadence !== undefined && !cscDevice) elements.cadence.textContent = Math.round(data.cadence);
    if (data.speed !== undefined && !cscDevice) elements.speed.textContent = data.speed.toFixed(1);
    if (data.resistance !== undefined) elements.resistance.textContent = data.resistance;
    if (data.avgPower !== undefined) elements.avgPower.textContent = data.avgPower;
    if (data.avgSpeed !== undefined && !cscDevice) elements.avgSpeed.textContent = data.avgSpeed.toFixed(1);
    if (data.avgCadence !== undefined && !cscDevice) elements.avgCadence.textContent = Math.round(data.avgCadence);
    if (data.heartRate !== undefined && !hrmDevice) elements.heartRate.textContent = data.heartRate;
    if (data.totalDistance !== undefined) elements.totalDistance.textContent = data.totalDistance;
    if (data.totalEnergy !== undefined) elements.totalEnergy.textContent = data.totalEnergy;
    if (data.elapsedTime !== undefined) elements.elapsedTime.textContent = formatTime(data.elapsedTime);
    if (data.remainingTime !== undefined) elements.remainingTime.textContent = formatTime(data.remainingTime);
}

// ── FTMS Trainer ──

async function connectTrainer() {
    try {
        log('Requesting Bluetooth device...');

        trainerDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [FTMS_SERVICE] }]
        });

        log(`Found device: ${trainerDevice.name}`, 'success');

        trainerDevice.addEventListener('gattserverdisconnected', onTrainerDisconnected);

        log('Connecting to GATT server...');
        trainerServer = await trainerDevice.gatt.connect();

        log('Getting FTMS service...');
        const service = await trainerServer.getPrimaryService(FTMS_SERVICE);

        // Get Indoor Bike Data characteristic
        try {
            indoorBikeDataChar = await service.getCharacteristic(INDOOR_BIKE_DATA);
            await indoorBikeDataChar.startNotifications();
            indoorBikeDataChar.addEventListener('characteristicvaluechanged', (event) => {
                const data = parseIndoorBikeData(event.target.value);
                updateMetrics(data);
            });
            log('Indoor Bike Data notifications started', 'success');
        } catch (e) {
            log(`Indoor Bike Data not available: ${e.message}`, 'error');
        }

        // Get Control Point
        try {
            controlPointChar = await service.getCharacteristic(CONTROL_POINT);
            await controlPointChar.startNotifications();
            controlPointChar.addEventListener('characteristicvaluechanged', (event) => {
                const response = new Uint8Array(event.target.value.buffer);
                log(`Control Point response: ${Array.from(response).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
            });

            await requestControl();
            log('Control Point ready', 'success');

            elements.applyResistance.disabled = false;
            elements.applyGrade.disabled = false;
        } catch (e) {
            log(`Control Point not available: ${e.message}`, 'error');
        }

        elements.trainerStatus.textContent = `Trainer: ${trainerDevice.name}`;
        elements.trainerStatus.className = 'status connected';
        elements.disconnect.disabled = false;
        elements.connectTrainer.disabled = true;

    } catch (error) {
        log(`Connection failed: ${error.message}`, 'error');
    }
}

async function requestControl() {
    if (!controlPointChar) return;
    try {
        const cmd = new Uint8Array([OP_REQUEST_CONTROL]);
        await controlPointChar.writeValueWithResponse(cmd);
        log('Control requested');
    } catch (e) {
        log(`Request control failed: ${e.message}`, 'error');
    }
}

async function setResistance(level) {
    if (!controlPointChar) return;
    try {
        const resistanceValue = Math.round(level * 10);
        const cmd = new Uint8Array([OP_SET_TARGET_RESISTANCE, resistanceValue]);
        await controlPointChar.writeValueWithResponse(cmd);
        log(`Resistance set to ${level}`);
    } catch (e) {
        log(`Set resistance failed: ${e.message}`, 'error');
    }
}

async function setSimulation(grade) {
    if (!controlPointChar) return;
    try {
        const windSpeed = 0;
        const gradeValue = Math.round(grade * 100);
        const crr = 40;  // 0.004 * 10000
        const cw = 51;   // 0.51 * 100 kg/m

        const cmd = new ArrayBuffer(7);
        const view = new DataView(cmd);
        view.setUint8(0, OP_SET_SIMULATION);
        view.setInt16(1, windSpeed, true);
        view.setInt16(3, gradeValue, true);
        view.setUint8(5, crr);
        view.setUint8(6, cw);

        await controlPointChar.writeValueWithResponse(new Uint8Array(cmd));
        log(`Simulation set: grade ${grade}%`);
    } catch (e) {
        log(`Set simulation failed: ${e.message}`, 'error');
    }
}

function onTrainerDisconnected() {
    log('Trainer disconnected', 'error');
    elements.trainerStatus.textContent = 'Trainer: Disconnected';
    elements.trainerStatus.className = 'status disconnected';
    elements.connectTrainer.disabled = false;
    elements.applyResistance.disabled = true;
    elements.applyGrade.disabled = true;
    trainerDevice = null;
    trainerServer = null;
    controlPointChar = null;
    indoorBikeDataChar = null;
}

// ── Heart Rate Monitor ──

async function connectHRM() {
    try {
        log('Requesting Heart Rate Monitor...');

        hrmDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [HRM_SERVICE] }]
        });

        log(`Found HRM: ${hrmDevice.name}`, 'success');

        hrmDevice.addEventListener('gattserverdisconnected', onHRMDisconnected);

        const server = await hrmDevice.gatt.connect();
        const service = await server.getPrimaryService(HRM_SERVICE);
        const hrmChar = await service.getCharacteristic(HRM_MEASUREMENT);

        await hrmChar.startNotifications();
        hrmChar.addEventListener('characteristicvaluechanged', (event) => {
            const hr = parseHeartRate(event.target.value);
            elements.heartRate.textContent = hr;
        });

        log('Heart Rate notifications started', 'success');

        elements.hrmStatus.textContent = `HRM: ${hrmDevice.name}`;
        elements.hrmStatus.className = 'status connected';
        elements.connectHRM.disabled = true;
        elements.disconnect.disabled = false;

    } catch (error) {
        log(`HRM connection failed: ${error.message}`, 'error');
    }
}

function parseHeartRate(dataView) {
    const flags = dataView.getUint8(0);
    // Bit 0: HR format — 0 = UINT8, 1 = UINT16
    if (flags & 0x01) {
        return dataView.getUint16(1, true);
    }
    return dataView.getUint8(1);
}

function onHRMDisconnected() {
    log('HRM disconnected', 'error');
    elements.hrmStatus.textContent = 'HRM: Disconnected';
    elements.hrmStatus.className = 'status disconnected';
    elements.connectHRM.disabled = false;
    hrmDevice = null;
}

// ── Cycling Speed and Cadence Sensor ──

async function connectCSC() {
    try {
        log('Requesting Speed/Cadence sensor...');

        cscDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [CSC_SERVICE] }]
        });

        log(`Found CSC: ${cscDevice.name}`, 'success');

        cscDevice.addEventListener('gattserverdisconnected', onCSCDisconnected);

        const server = await cscDevice.gatt.connect();
        const service = await server.getPrimaryService(CSC_SERVICE);
        const cscChar = await service.getCharacteristic(CSC_MEASUREMENT);

        await cscChar.startNotifications();
        cscChar.addEventListener('characteristicvaluechanged', (event) => {
            handleCSCMeasurement(event.target.value);
        });

        log('CSC notifications started', 'success');

        elements.cscStatus.textContent = `Speed/Cadence: ${cscDevice.name}`;
        elements.cscStatus.className = 'status connected';
        elements.connectCSC.disabled = true;
        elements.disconnect.disabled = false;

    } catch (error) {
        log(`CSC connection failed: ${error.message}`, 'error');
    }
}

function handleCSCMeasurement(dataView) {
    const flags = dataView.getUint8(0);
    let offset = 1;

    // Bit 0: Wheel Revolution Data Present
    if (flags & 0x01) {
        const wheelRevs = dataView.getUint32(offset, true);
        offset += 4;
        const wheelTime = dataView.getUint16(offset, true); // 1/1024 sec
        offset += 2;

        if (lastWheelRevs !== null && wheelRevs !== lastWheelRevs) {
            // UINT32 for wheel revs — no practical wraparound
            const revsDiff = wheelRevs - lastWheelRevs;
            const timeDiff = uint16Diff(wheelTime, lastWheelTime);
            if (timeDiff > 0) {
                const speed = (revsDiff * WHEEL_CIRCUMFERENCE / (timeDiff / 1024)) * 3.6;
                elements.speed.textContent = speed.toFixed(1);
            }
        } else if (lastWheelRevs !== null && wheelRevs === lastWheelRevs) {
            elements.speed.textContent = '0.0';
        }
        lastWheelRevs = wheelRevs;
        lastWheelTime = wheelTime;
    }

    // Bit 1: Crank Revolution Data Present
    if (flags & 0x02) {
        const crankRevs = dataView.getUint16(offset, true);
        offset += 2;
        const crankTime = dataView.getUint16(offset, true); // 1/1024 sec
        offset += 2;

        if (lastCrankRevs !== null) {
            const revsDiff = uint16Diff(crankRevs, lastCrankRevs);
            const timeDiff = uint16Diff(crankTime, lastCrankTime);
            if (timeDiff > 0 && revsDiff > 0) {
                const cadence = (revsDiff / (timeDiff / 1024)) * 60;
                elements.cadence.textContent = Math.round(cadence);
            } else if (revsDiff === 0) {
                elements.cadence.textContent = '0';
            }
        }
        lastCrankRevs = crankRevs;
        lastCrankTime = crankTime;
    }
}

function onCSCDisconnected() {
    log('Speed/Cadence sensor disconnected', 'error');
    elements.cscStatus.textContent = 'Speed/Cadence: Disconnected';
    elements.cscStatus.className = 'status disconnected';
    elements.connectCSC.disabled = false;
    cscDevice = null;
    lastCrankRevs = null;
    lastCrankTime = null;
    lastWheelRevs = null;
    lastWheelTime = null;
}

// ── Zwift Click ──

function onClickDisconnected() {
    log('Click disconnected', 'error');
    elements.clickStatus.textContent = 'Zwift Click: Disconnected';
    elements.clickStatus.className = 'status disconnected';
    elements.connectClick.disabled = false;
    clickDevice = null;
    lastButtonState = 0xFFFFFFFF;
}

async function connectClick() {
    try {
        log('Requesting Zwift Click device...');

        clickDevice = await navigator.bluetooth.requestDevice({
            filters: [
                { namePrefix: 'Zwift Click' },
                { namePrefix: 'ZC' },
                { services: [ZWIFT_SERVICE_NEW] }
            ],
            optionalServices: [ZWIFT_SERVICE_LEGACY, ZWIFT_SERVICE_NEW]
        });

        log(`Found Click: ${clickDevice.name}`, 'success');

        clickDevice.addEventListener('gattserverdisconnected', onClickDisconnected);

        const server = await clickDevice.gatt.connect();

        log('Discovering services...');
        const services = await server.getPrimaryServices();
        for (const svc of services) {
            log(`Found service: ${svc.uuid}`);
        }

        let service = null;
        let useNewProtocol = false;

        try {
            service = await server.getPrimaryService(ZWIFT_SERVICE_LEGACY);
            log('Using legacy Zwift protocol', 'success');
        } catch (e) {
            log(`Legacy service not found: ${e.message}`);
            try {
                service = await server.getPrimaryService(ZWIFT_SERVICE_NEW);
                useNewProtocol = true;
                log('Using new Zwift protocol (FC82)', 'success');
            } catch (e2) {
                log(`New service not found: ${e2.message}`, 'error');
                throw new Error('No compatible Zwift service found');
            }
        }

        log('Discovering characteristics...');
        const characteristics = await service.getCharacteristics();
        for (const char of characteristics) {
            const props = [];
            if (char.properties.read) props.push('read');
            if (char.properties.write) props.push('write');
            if (char.properties.writeWithoutResponse) props.push('writeNoResp');
            if (char.properties.notify) props.push('notify');
            if (char.properties.indicate) props.push('indicate');
            log(`  Char: ${char.uuid} [${props.join(', ')}]`);
        }

        if (useNewProtocol) {
            let syncRxChar = null;

            for (const char of characteristics) {
                const uuid = char.uuid;

                if (char.properties.notify || char.properties.indicate) {
                    try {
                        await char.startNotifications();
                        char.addEventListener('characteristicvaluechanged', (event) => {
                            const data = new Uint8Array(event.target.value.buffer);
                            const charUuid = event.target.uuid;
                            handleClickInput(data, charUuid);
                        });
                        log(`Subscribed: ${uuid}`, 'success');
                    } catch (e) {
                        log(`Failed to subscribe ${uuid}: ${e.message}`, 'error');
                    }
                }

                if (uuid.includes('00000003')) {
                    syncRxChar = char;
                }
            }

            if (syncRxChar) {
                const handshake = new TextEncoder().encode('RideOn');
                try {
                    await syncRxChar.writeValueWithoutResponse(handshake);
                    log('Handshake "RideOn" sent to 0x0003', 'success');
                } catch (e) {
                    log(`Handshake failed: ${e.message}`, 'error');
                }
            } else {
                log('SYNC_RX characteristic (0x0003) not found', 'error');
            }
        } else {
            const asyncChar = await service.getCharacteristic(ZWIFT_ASYNC_LEGACY);
            const syncRxChar = await service.getCharacteristic(ZWIFT_SYNC_RX_LEGACY);
            const syncTxChar = await service.getCharacteristic(ZWIFT_SYNC_TX_LEGACY);

            await syncTxChar.startNotifications();
            syncTxChar.addEventListener('characteristicvaluechanged', (event) => {
                const data = new Uint8Array(event.target.value.buffer);
                const text = new TextDecoder().decode(data.slice(0, 6));
                if (text === 'RideOn') {
                    log('Handshake successful!', 'success');
                }
            });

            await asyncChar.startNotifications();
            asyncChar.addEventListener('characteristicvaluechanged', (event) => {
                const data = new Uint8Array(event.target.value.buffer);
                handleClickInput(data, event.target.uuid);
            });

            const handshake = new TextEncoder().encode('RideOn');
            await syncRxChar.writeValueWithResponse(handshake);
            log('Handshake sent');
        }

        elements.clickStatus.textContent = `Zwift Click: ${clickDevice.name}`;
        elements.clickStatus.className = 'status connected';
        elements.connectClick.disabled = true;
        elements.disconnect.disabled = false;

    } catch (error) {
        log(`Click connection failed: ${error.message}`, 'error');
    }
}

// Track button state to detect edges (press/release)
let lastButtonState = 0xFFFFFFFF;

function handleClickInput(data, charUuid = 'unknown') {
    const shortUuid = charUuid.substring(4, 8);

    if (data.length >= 6) {
        const text = new TextDecoder().decode(data.slice(0, 6));
        if (text === 'RideOn') {
            log('Handshake response received!', 'success');
            return;
        }
    }

    if (data.length === 0) return;

    const messageId = data[0];

    if (messageId === 0x23 && data.length >= 7) {
        const b0 = data[2];
        const b1 = data[3];
        const b2 = data[4];
        const b3 = data[5];
        const buttons = ((b3 << 24) | (b2 << 16) | (b1 << 8) | b0) >>> 0;

        const pressed = (~buttons) >>> 0;
        const lastPressed = (~lastButtonState) >>> 0;
        const newlyPressed = pressed & ~lastPressed;

        const SHIFT_DOWN_BIT = 0x00000200;
        const SHIFT_UP_BIT = 0x00002000;

        if (newlyPressed & SHIFT_DOWN_BIT) {
            log('Shift DOWN detected', 'success');
            changeGear(-1);
        }
        if (newlyPressed & SHIFT_UP_BIT) {
            log('Shift UP detected', 'success');
            changeGear(1);
        }

        if (newlyPressed !== 0) {
            log(`Button press: 0x${newlyPressed.toString(16).padStart(8, '0')}`);
        }

        lastButtonState = buttons;
        return;
    }

    if (messageId === 0x19 || messageId === 0x15) {
        return;
    }

    const hex = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
    log(`[${shortUuid}] ${hex}`);
}

// ── Gears ──

function changeGear(delta) {
    const newGear = Math.max(MIN_GEAR, Math.min(MAX_GEAR, currentGear + delta));
    if (newGear !== currentGear) {
        currentGear = newGear;
        elements.currentGear.textContent = currentGear;

        const resistance = (currentGear / MAX_GEAR) * 25;
        log(`Gear ${currentGear} (resistance ~${resistance.toFixed(1)})`);

        if (controlPointChar) {
            setResistance(resistance);
        }
    }
}

// ── Disconnect ──

function disconnectAll() {
    if (trainerDevice && trainerDevice.gatt.connected) {
        trainerDevice.gatt.disconnect();
    }
    if (hrmDevice && hrmDevice.gatt.connected) {
        hrmDevice.gatt.disconnect();
    }
    if (cscDevice && cscDevice.gatt.connected) {
        cscDevice.gatt.disconnect();
    }
    if (clickDevice && clickDevice.gatt.connected) {
        clickDevice.gatt.disconnect();
    }
    elements.disconnect.disabled = true;
}

// ── Event listeners ──

elements.connectTrainer.addEventListener('click', connectTrainer);
elements.connectHRM.addEventListener('click', connectHRM);
elements.connectCSC.addEventListener('click', connectCSC);
elements.connectClick.addEventListener('click', connectClick);
elements.disconnect.addEventListener('click', disconnectAll);

elements.gearUp.addEventListener('click', () => changeGear(1));
elements.gearDown.addEventListener('click', () => changeGear(-1));

elements.resistanceSlider.addEventListener('input', (e) => {
    elements.resistanceValue.textContent = e.target.value;
});

elements.applyResistance.addEventListener('click', () => {
    setResistance(parseFloat(elements.resistanceSlider.value));
});

elements.gradeSlider.addEventListener('input', (e) => {
    elements.gradeValue.textContent = e.target.value;
});

elements.applyGrade.addEventListener('click', () => {
    setSimulation(parseFloat(elements.gradeSlider.value));
});

// Keyboard shortcuts (skip when focused on form controls)
document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
    if (e.key === 'ArrowUp' || e.key === '+') changeGear(1);
    if (e.key === 'ArrowDown' || e.key === '-') changeGear(-1);
});

// Check Web Bluetooth support
if (!navigator.bluetooth) {
    log('Web Bluetooth is not supported in this browser!', 'error');
    elements.connectTrainer.disabled = true;
    elements.connectHRM.disabled = true;
    elements.connectCSC.disabled = true;
    elements.connectClick.disabled = true;
}
</script>
</body>
</html>
