<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FTMS Bike Trainer Console</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: #1a1a2e; color: #eee; padding: 20px; min-height: 100vh; }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 20px; color: #00d4ff; }
        .connection { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer;
                 font-size: 16px; transition: all 0.2s; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: #00d4ff; color: #1a1a2e; }
        .btn-primary:hover:not(:disabled) { background: #00a8cc; }
        .btn-secondary { background: #4a4a6a; color: #eee; }
        .btn-secondary:hover:not(:disabled) { background: #5a5a7a; }
        .btn-danger { background: #ff4757; color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #ff3344; }
        .status { text-align: center; padding: 10px; margin-bottom: 20px; border-radius: 8px; }
        .status.connected { background: #2ed57320; border: 1px solid #2ed573; }
        .status.disconnected { background: #ff475720; border: 1px solid #ff4757; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .metric { background: #252545; padding: 20px; border-radius: 12px; text-align: center; }
        .metric-value { font-size: 36px; font-weight: bold; color: #00d4ff; }
        .metric-unit { font-size: 14px; color: #888; }
        .metric-label { font-size: 12px; color: #aaa; margin-top: 5px; text-transform: uppercase; }
        .controls { background: #252545; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 8px; color: #aaa; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { text-align: center; font-size: 24px; color: #00d4ff; }
        .gears { display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap; }
        .gear-display { font-size: 48px; font-weight: bold; color: #ffd700; min-width: 80px; text-align: center; }
        .log { background: #252545; padding: 15px; border-radius: 12px; max-height: 200px; overflow-y: auto; }
        .log-entry { font-family: monospace; font-size: 12px; color: #888; margin-bottom: 5px; }
        .log-entry.error { color: #ff4757; }
        .log-entry.success { color: #2ed573; }
    </style>
</head>
<body>
    <div class="container">
        <h1>FTMS Bike Trainer</h1>

        <div class="connection">
            <button id="connectTrainer" class="btn-primary">Connect Trainer</button>
            <button id="connectClick" class="btn-secondary">Connect Zwift Click</button>
            <button id="disconnect" class="btn-danger" disabled>Disconnect</button>
        </div>

        <div id="trainerStatus" class="status disconnected">Trainer: Disconnected</div>
        <div id="clickStatus" class="status disconnected">Zwift Click: Disconnected</div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="power">--</div>
                <div class="metric-unit">W</div>
                <div class="metric-label">Power</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="cadence">--</div>
                <div class="metric-unit">rpm</div>
                <div class="metric-label">Cadence</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="speed">--</div>
                <div class="metric-unit">km/h</div>
                <div class="metric-label">Speed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="resistance">--</div>
                <div class="metric-unit">%</div>
                <div class="metric-label">Resistance</div>
            </div>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #aaa;">Virtual Gears</h3>
            <div class="gears">
                <button id="gearDown" class="btn-secondary">&#9664; Easier</button>
                <div class="gear-display" id="currentGear">12</div>
                <button id="gearUp" class="btn-secondary">Harder &#9654;</button>
            </div>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #aaa;">Manual Resistance</h3>
            <div class="control-group">
                <input type="range" id="resistanceSlider" min="0" max="100" value="50">
                <div class="value"><span id="resistanceValue">50</span>%</div>
            </div>
            <button id="applyResistance" class="btn-primary" disabled>Apply Resistance</button>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #aaa;">Simulation (Grade)</h3>
            <div class="control-group">
                <input type="range" id="gradeSlider" min="-10" max="15" value="0" step="0.5">
                <div class="value"><span id="gradeValue">0</span>%</div>
            </div>
            <button id="applyGrade" class="btn-primary" disabled>Apply Grade</button>
        </div>

        <div class="log" id="log"></div>
    </div>

<script>
// FTMS UUIDs
const FTMS_SERVICE = 0x1826;
const INDOOR_BIKE_DATA = 0x2AD2;
const CONTROL_POINT = 0x2AD9;
const MACHINE_STATUS = 0x2ADA;
const SUPPORTED_RESISTANCE_RANGE = 0x2AD6;

// Zwift Click UUIDs - Legacy (pre-2025)
const ZWIFT_SERVICE_LEGACY = '00000001-19ca-4651-86e5-fa29dcdd09d1';
const ZWIFT_ASYNC_LEGACY = '00000002-19ca-4651-86e5-fa29dcdd09d1';
const ZWIFT_SYNC_RX_LEGACY = '00000003-19ca-4651-86e5-fa29dcdd09d1';
const ZWIFT_SYNC_TX_LEGACY = '00000004-19ca-4651-86e5-fa29dcdd09d1';

// Zwift Click UUIDs - New (2025+)
const ZWIFT_SERVICE_NEW = 0xFC82;

// Control Point Opcodes
const OP_REQUEST_CONTROL = 0x00;
const OP_RESET = 0x01;
const OP_SET_TARGET_RESISTANCE = 0x04;
const OP_SET_TARGET_POWER = 0x05;
const OP_START = 0x07;
const OP_STOP = 0x08;
const OP_SET_SIMULATION = 0x11;

// State
let trainerDevice = null;
let trainerServer = null;
let controlPointChar = null;
let indoorBikeDataChar = null;
let clickDevice = null;
let currentGear = 12;
const MIN_GEAR = 1;
const MAX_GEAR = 24;

// DOM Elements
const elements = {
    connectTrainer: document.getElementById('connectTrainer'),
    connectClick: document.getElementById('connectClick'),
    disconnect: document.getElementById('disconnect'),
    trainerStatus: document.getElementById('trainerStatus'),
    clickStatus: document.getElementById('clickStatus'),
    power: document.getElementById('power'),
    cadence: document.getElementById('cadence'),
    speed: document.getElementById('speed'),
    resistance: document.getElementById('resistance'),
    currentGear: document.getElementById('currentGear'),
    gearUp: document.getElementById('gearUp'),
    gearDown: document.getElementById('gearDown'),
    resistanceSlider: document.getElementById('resistanceSlider'),
    resistanceValue: document.getElementById('resistanceValue'),
    applyResistance: document.getElementById('applyResistance'),
    gradeSlider: document.getElementById('gradeSlider'),
    gradeValue: document.getElementById('gradeValue'),
    applyGrade: document.getElementById('applyGrade'),
    log: document.getElementById('log')
};

// Logging
function log(message, type = 'info') {
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    elements.log.insertBefore(entry, elements.log.firstChild);
    console.log(message);
}

// Parse Indoor Bike Data characteristic
function parseIndoorBikeData(dataView) {
    const flags = dataView.getUint16(0, true);
    let offset = 2;
    const data = {};

    // Bit 0 = 0 means Instantaneous Speed is present (inverted logic!)
    if ((flags & 0x01) === 0) {
        data.speed = dataView.getUint16(offset, true) / 100; // km/h
        offset += 2;
    }

    // Bit 1: Average Speed
    if (flags & 0x02) {
        data.avgSpeed = dataView.getUint16(offset, true) / 100;
        offset += 2;
    }

    // Bit 2: Instantaneous Cadence
    if (flags & 0x04) {
        data.cadence = dataView.getUint16(offset, true) / 2; // rpm
        offset += 2;
    }

    // Bit 3: Average Cadence
    if (flags & 0x08) {
        data.avgCadence = dataView.getUint16(offset, true) / 2;
        offset += 2;
    }

    // Bit 4: Total Distance (24-bit)
    if (flags & 0x10) {
        data.totalDistance = dataView.getUint16(offset, true) +
                            (dataView.getUint8(offset + 2) << 16);
        offset += 3;
    }

    // Bit 5: Resistance Level
    if (flags & 0x20) {
        data.resistance = dataView.getInt16(offset, true);
        offset += 2;
    }

    // Bit 6: Instantaneous Power
    if (flags & 0x40) {
        data.power = dataView.getInt16(offset, true); // watts
        offset += 2;
    }

    // Bit 7: Average Power
    if (flags & 0x80) {
        data.avgPower = dataView.getInt16(offset, true);
        offset += 2;
    }

    return data;
}

// Update UI with bike data
function updateMetrics(data) {
    if (data.power !== undefined) elements.power.textContent = data.power;
    if (data.cadence !== undefined) elements.cadence.textContent = Math.round(data.cadence);
    if (data.speed !== undefined) elements.speed.textContent = data.speed.toFixed(1);
    if (data.resistance !== undefined) elements.resistance.textContent = data.resistance;
}

// Connect to FTMS Trainer
async function connectTrainer() {
    try {
        log('Requesting Bluetooth device...');

        trainerDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [FTMS_SERVICE] }],
            optionalServices: [FTMS_SERVICE]
        });

        log(`Found device: ${trainerDevice.name}`, 'success');

        trainerDevice.addEventListener('gattserverdisconnected', onTrainerDisconnected);

        log('Connecting to GATT server...');
        trainerServer = await trainerDevice.gatt.connect();

        log('Getting FTMS service...');
        const service = await trainerServer.getPrimaryService(FTMS_SERVICE);

        // Get Indoor Bike Data characteristic
        try {
            indoorBikeDataChar = await service.getCharacteristic(INDOOR_BIKE_DATA);
            await indoorBikeDataChar.startNotifications();
            indoorBikeDataChar.addEventListener('characteristicvaluechanged', (event) => {
                const data = parseIndoorBikeData(event.target.value);
                updateMetrics(data);
            });
            log('Indoor Bike Data notifications started', 'success');
        } catch (e) {
            log(`Indoor Bike Data not available: ${e.message}`, 'error');
        }

        // Get Control Point
        try {
            controlPointChar = await service.getCharacteristic(CONTROL_POINT);
            await controlPointChar.startNotifications();
            controlPointChar.addEventListener('characteristicvaluechanged', (event) => {
                const response = new Uint8Array(event.target.value.buffer);
                log(`Control Point response: ${Array.from(response).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
            });

            // Request control
            await requestControl();
            log('Control Point ready', 'success');

            elements.applyResistance.disabled = false;
            elements.applyGrade.disabled = false;
        } catch (e) {
            log(`Control Point not available: ${e.message}`, 'error');
        }

        elements.trainerStatus.textContent = `Trainer: ${trainerDevice.name}`;
        elements.trainerStatus.className = 'status connected';
        elements.disconnect.disabled = false;
        elements.connectTrainer.disabled = true;

    } catch (error) {
        log(`Connection failed: ${error.message}`, 'error');
    }
}

// Request control of the trainer
async function requestControl() {
    if (!controlPointChar) return;
    const cmd = new Uint8Array([OP_REQUEST_CONTROL]);
    await controlPointChar.writeValue(cmd);
    log('Control requested');
}

// Set resistance level (0-100)
async function setResistance(level) {
    if (!controlPointChar) return;
    // Resistance is in 0.1 units, so multiply by 10
    const resistanceValue = Math.round(level * 10);
    const cmd = new Uint8Array([OP_SET_TARGET_RESISTANCE, resistanceValue & 0xFF]);
    await controlPointChar.writeValue(cmd);
    log(`Resistance set to ${level}%`);
}

// Set simulation parameters (grade in %)
async function setSimulation(grade) {
    if (!controlPointChar) return;

    // Parameters: wind speed (m/s), grade (%), Crr, Cw
    const windSpeed = 0; // m/s * 1000
    const gradeValue = Math.round(grade * 100); // % * 100 (signed int16)
    const crr = 0; // Rolling resistance * 10000
    const cw = 0; // Wind resistance * 100

    const cmd = new ArrayBuffer(7);
    const view = new DataView(cmd);
    view.setUint8(0, OP_SET_SIMULATION);
    view.setInt16(1, windSpeed, true);
    view.setInt16(3, gradeValue, true);
    view.setUint8(5, crr);
    view.setUint8(6, cw);

    await controlPointChar.writeValue(new Uint8Array(cmd));
    log(`Simulation set: grade ${grade}%`);
}

// Handle trainer disconnection
function onTrainerDisconnected() {
    log('Trainer disconnected', 'error');
    elements.trainerStatus.textContent = 'Trainer: Disconnected';
    elements.trainerStatus.className = 'status disconnected';
    elements.connectTrainer.disabled = false;
    elements.applyResistance.disabled = true;
    elements.applyGrade.disabled = true;
    trainerDevice = null;
    controlPointChar = null;
}

// Connect to Zwift Click
async function connectClick() {
    try {
        log('Requesting Zwift Click device...');

        // Use acceptAllDevices and filter by name, request both service UUIDs as optional
        clickDevice = await navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [ZWIFT_SERVICE_LEGACY, ZWIFT_SERVICE_NEW]
        });

        log(`Found Click: ${clickDevice.name}`, 'success');

        clickDevice.addEventListener('gattserverdisconnected', () => {
            log('Click disconnected', 'error');
            elements.clickStatus.textContent = 'Zwift Click: Disconnected';
            elements.clickStatus.className = 'status disconnected';
        });

        const server = await clickDevice.gatt.connect();

        // Try to get all services and log them for debugging
        log('Discovering services...');
        const services = await server.getPrimaryServices();
        for (const svc of services) {
            log(`Found service: ${svc.uuid}`);
        }

        // Try legacy service first, then new
        let service = null;
        let useNewProtocol = false;

        try {
            service = await server.getPrimaryService(ZWIFT_SERVICE_LEGACY);
            log('Using legacy Zwift protocol', 'success');
        } catch (e) {
            log(`Legacy service not found: ${e.message}`);
            try {
                service = await server.getPrimaryService(ZWIFT_SERVICE_NEW);
                useNewProtocol = true;
                log('Using new Zwift protocol (FC82)', 'success');
            } catch (e2) {
                log(`New service not found: ${e2.message}`, 'error');
                throw new Error('No compatible Zwift service found');
            }
        }

        // Get all characteristics and log them
        log('Discovering characteristics...');
        const characteristics = await service.getCharacteristics();
        for (const char of characteristics) {
            const props = [];
            if (char.properties.read) props.push('read');
            if (char.properties.write) props.push('write');
            if (char.properties.writeWithoutResponse) props.push('writeNoResp');
            if (char.properties.notify) props.push('notify');
            if (char.properties.indicate) props.push('indicate');
            log(`  Char: ${char.uuid} [${props.join(', ')}]`);
        }

        if (useNewProtocol) {
            // New protocol FC82 - still needs handshake on same characteristic UUIDs
            // Char 0x0002 = ASYNC (notify) - button data
            // Char 0x0003 = SYNC_RX (write) - send commands/handshake
            // Char 0x0004 = SYNC_TX (indicate) - receive responses
            // Char 0x0100, 0x0101, 0x0102 = new characteristics

            // Get the key characteristics
            let syncRxChar = null;
            let syncTxChar = null;

            for (const char of characteristics) {
                const uuid = char.uuid;

                // Subscribe to all notify AND indicate characteristics
                if (char.properties.notify || char.properties.indicate) {
                    try {
                        await char.startNotifications();
                        char.addEventListener('characteristicvaluechanged', (event) => {
                            const data = new Uint8Array(event.target.value.buffer);
                            const charUuid = event.target.uuid;
                            handleClickInput(data, charUuid);
                        });
                        log(`Subscribed: ${uuid}`, 'success');
                    } catch (e) {
                        log(`Failed to subscribe ${uuid}: ${e.message}`, 'error');
                    }
                }

                // Identify write characteristic for handshake (0x0003)
                if (uuid.includes('00000003')) {
                    syncRxChar = char;
                }
                if (uuid.includes('00000004')) {
                    syncTxChar = char;
                }
            }

            // Send handshake "RideOn" to SYNC_RX (0x0003)
            if (syncRxChar) {
                const handshake = new TextEncoder().encode('RideOn');
                try {
                    await syncRxChar.writeValueWithoutResponse(handshake);
                    log('Handshake "RideOn" sent to 0x0003', 'success');
                } catch (e) {
                    log(`Handshake failed: ${e.message}`, 'error');
                }
            } else {
                log('SYNC_RX characteristic (0x0003) not found', 'error');
            }
        } else {
            // Legacy protocol with handshake
            const asyncChar = await service.getCharacteristic(ZWIFT_ASYNC_LEGACY);
            const syncRxChar = await service.getCharacteristic(ZWIFT_SYNC_RX_LEGACY);
            const syncTxChar = await service.getCharacteristic(ZWIFT_SYNC_TX_LEGACY);

            // Setup notifications for SYNC_TX (handshake response)
            await syncTxChar.startNotifications();
            syncTxChar.addEventListener('characteristicvaluechanged', (event) => {
                const data = new Uint8Array(event.target.value.buffer);
                const text = new TextDecoder().decode(data.slice(0, 6));
                if (text === 'RideOn') {
                    log('Handshake successful!', 'success');
                }
            });

            // Setup notifications for ASYNC (button presses)
            await asyncChar.startNotifications();
            asyncChar.addEventListener('characteristicvaluechanged', (event) => {
                const data = new Uint8Array(event.target.value.buffer);
                handleClickInput(data, event.target.uuid);
            });

            // Send handshake
            const handshake = new TextEncoder().encode('RideOn');
            await syncRxChar.writeValue(handshake);
            log('Handshake sent');
        }

        elements.clickStatus.textContent = `Zwift Click: ${clickDevice.name}`;
        elements.clickStatus.className = 'status connected';

    } catch (error) {
        log(`Click connection failed: ${error.message}`, 'error');
    }
}

// Track button state to detect edges (press/release)
let lastButtonState = 0xFFFFFFFF;

// Handle Zwift Click button input
function handleClickInput(data, charUuid = 'unknown') {
    const shortUuid = charUuid.substring(4, 8);

    // Check for handshake response
    if (data.length >= 6) {
        const text = new TextDecoder().decode(data.slice(0, 6));
        if (text === 'RideOn') {
            log('Handshake response received!', 'success');
            return;
        }
    }

    if (data.length === 0) return;

    const messageId = data[0];

    // Keystroke message (0x23)
    // Format: 23 08 [b0 b1 b2 b3] 0f
    // Bytes 2-5 are button bitmap (little-endian), 0 = pressed (inverted)
    if (messageId === 0x23 && data.length >= 7) {
        // Read 32-bit button bitmap from bytes 2-5 (after 0x23 0x08)
        const b0 = data[2];
        const b1 = data[3];
        const b2 = data[4];
        const b3 = data[5];
        const buttons = ((b3 << 24) | (b2 << 16) | (b1 << 8) | b0) >>> 0;

        // Invert to get pressed buttons (1 = pressed)
        const pressed = (~buttons) >>> 0;

        // Detect newly pressed buttons (edge detection)
        const lastPressed = (~lastButtonState) >>> 0;
        const newlyPressed = pressed & ~lastPressed;

        // Known button bits from analysis:
        // Bit 9 (0x0200) in b1 = 0xfd = shift down (easier gear)
        // Bit 13 (0x2000) in b1 = 0xdf = shift up (harder gear)
        const SHIFT_DOWN_BIT = 0x00000200; // b1 bit 1 (0xfd)
        const SHIFT_UP_BIT = 0x00002000;   // b1 bit 5 (0xdf)

        if (newlyPressed & SHIFT_DOWN_BIT) {
            log('Shift DOWN detected', 'success');
            changeGear(-1);
        }
        if (newlyPressed & SHIFT_UP_BIT) {
            log('Shift UP detected', 'success');
            changeGear(1);
        }

        // Debug: log any button press
        if (newlyPressed !== 0) {
            log(`Button press: 0x${newlyPressed.toString(16).padStart(8, '0')}`);
        }

        lastButtonState = buttons;
        return;
    }

    // Idle/keepalive message (0x19, 0x15) - ignore silently
    if (messageId === 0x19 || messageId === 0x15) {
        return;
    }

    // Other messages - log for debugging
    const hex = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
    log(`[${shortUuid}] ${hex}`);
}

// Change gear
function changeGear(delta) {
    const newGear = Math.max(MIN_GEAR, Math.min(MAX_GEAR, currentGear + delta));
    if (newGear !== currentGear) {
        currentGear = newGear;
        elements.currentGear.textContent = currentGear;

        // Calculate resistance based on gear (simple linear mapping)
        const resistance = (currentGear / MAX_GEAR) * 100;
        log(`Gear ${currentGear} (resistance ~${resistance.toFixed(0)}%)`);

        // Optionally apply to trainer
        if (controlPointChar) {
            setResistance(resistance);
        }
    }
}

// Disconnect all
function disconnectAll() {
    if (trainerDevice && trainerDevice.gatt.connected) {
        trainerDevice.gatt.disconnect();
    }
    if (clickDevice && clickDevice.gatt.connected) {
        clickDevice.gatt.disconnect();
    }
    elements.disconnect.disabled = true;
}

// Event listeners
elements.connectTrainer.addEventListener('click', connectTrainer);
elements.connectClick.addEventListener('click', connectClick);
elements.disconnect.addEventListener('click', disconnectAll);

elements.gearUp.addEventListener('click', () => changeGear(1));
elements.gearDown.addEventListener('click', () => changeGear(-1));

elements.resistanceSlider.addEventListener('input', (e) => {
    elements.resistanceValue.textContent = e.target.value;
});

elements.applyResistance.addEventListener('click', () => {
    setResistance(parseInt(elements.resistanceSlider.value));
});

elements.gradeSlider.addEventListener('input', (e) => {
    elements.gradeValue.textContent = e.target.value;
});

elements.applyGrade.addEventListener('click', () => {
    setSimulation(parseFloat(elements.gradeSlider.value));
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === '+') changeGear(1);
    if (e.key === 'ArrowDown' || e.key === '-') changeGear(-1);
});

// Check Web Bluetooth support
if (!navigator.bluetooth) {
    log('Web Bluetooth is not supported in this browser!', 'error');
    elements.connectTrainer.disabled = true;
    elements.connectClick.disabled = true;
}
</script>
</body>
</html>
